{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"004 Programming Paradigms 003 Futamura Projection 002 Crafting IsOdd() 001 SICP Exercise 3.2","title":"Home"},{"location":"post/001/","text":"SICP Exercise 3.2 Structure and Interpretation of Computer Programs Exercise 3.2. In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a procedure make-monitored that takes as input a procedure, f, that itself takes one input. The result returned by make-monitored is a third procedure, say mf, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to mf is the special symbol how-many-calls?, then mf returns the value of the counter. If the input is the special symbol reset-count, then mf resets the counter to zero. For any other input, mf returns the result of calling f on that input and increments the counter. For instance, we could make a monitored version of the sqrt procedure: (define s (make-monitored sqrt)) (s 100) 10 (s 'how-many-calls?) 1 Implementation #lang racket (define (make-monitored f) (define count 0) (define (mf a) (cond [(eq? a 'how-many-calls?) count] [(eq? a 'reset-count) (set! count 0)] [else (set! count (+ count 1)) (f a)] ) ) mf ) Test (define s (make-monitored sqrt)) (s 144) ; 12 (s 121) ; 11 (s 'how-many-calls?) ; 2 (s 'reset-count) (s 9) ; 3 (s 'how-many-calls?) ; 1 Epilog This is my attempt on SICP Exercise 3.2 in the programming language Racket. I am impressed that the Scheme code in the book still runs unchanged several decades later in Racket. Posted: 2025-08-19 Next","title":"SICP Exercise 3.2"},{"location":"post/001/#sicp-exercise-32","text":"Structure and Interpretation of Computer Programs Exercise 3.2. In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a procedure make-monitored that takes as input a procedure, f, that itself takes one input. The result returned by make-monitored is a third procedure, say mf, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to mf is the special symbol how-many-calls?, then mf returns the value of the counter. If the input is the special symbol reset-count, then mf resets the counter to zero. For any other input, mf returns the result of calling f on that input and increments the counter. For instance, we could make a monitored version of the sqrt procedure: (define s (make-monitored sqrt)) (s 100) 10 (s 'how-many-calls?) 1 Implementation #lang racket (define (make-monitored f) (define count 0) (define (mf a) (cond [(eq? a 'how-many-calls?) count] [(eq? a 'reset-count) (set! count 0)] [else (set! count (+ count 1)) (f a)] ) ) mf ) Test (define s (make-monitored sqrt)) (s 144) ; 12 (s 121) ; 11 (s 'how-many-calls?) ; 2 (s 'reset-count) (s 9) ; 3 (s 'how-many-calls?) ; 1 Epilog This is my attempt on SICP Exercise 3.2 in the programming language Racket. I am impressed that the Scheme code in the book still runs unchanged several decades later in Racket. Posted: 2025-08-19 Next","title":"SICP Exercise 3.2"},{"location":"post/002/","text":"Crafting IsOdd() Mutually Recursive Crafting Interpreters chapter 8 shows us an interesting way to implement IsOdd() & IsEven() by mutually calling each other recursively. Implementation in Go package main import \"fmt\" func isOdd(i int) bool { if i == 0 { return false } else { return isEven(i - 1) } } func isEven(i int) bool { if i == 0 { return true } else { return isOdd(i - 1) } } func main() { fmt.Println(isOdd(100)) // print false fmt.Println(isOdd(101)) // print true fmt.Println(isEven(100)) // print true fmt.Println(isEven(101)) // print false } Epilog Crafting Interpreters is handcrafted by Robert Nystrom. Posted: 2025-10-14 Previous - Next","title":"Crafting IsOdd()"},{"location":"post/002/#crafting-isodd","text":"Mutually Recursive Crafting Interpreters chapter 8 shows us an interesting way to implement IsOdd() & IsEven() by mutually calling each other recursively. Implementation in Go package main import \"fmt\" func isOdd(i int) bool { if i == 0 { return false } else { return isEven(i - 1) } } func isEven(i int) bool { if i == 0 { return true } else { return isOdd(i - 1) } } func main() { fmt.Println(isOdd(100)) // print false fmt.Println(isOdd(101)) // print true fmt.Println(isEven(100)) // print true fmt.Println(isEven(101)) // print false } Epilog Crafting Interpreters is handcrafted by Robert Nystrom. Posted: 2025-10-14 Previous - Next","title":"Crafting IsOdd()"},{"location":"post/003/","text":"Futamura Projection If you search online for Futamura Projection, it will redirect you to the Partial Evaluation Wikipedia page. So how are they related? Partial evaluation is a technique to move some of the runtime work to compile time, thereby speeding up the executable. Futamura projection is to repeatedly apply partial evaluation to an interpreter, thereby creating a JIT compiler. The following diagrams are based on a talk by Tom Stuart which explains Futamura projections in a way I can understand. Initial Source-->+-------------+ Input-->| Interpreter |-->Output +-------------+ Projection 1 Interpreter-->+-------------+ Source-->| PE1 |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Projection 2 +-------------+<--PE1 Compiler<--| PE2 |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Projection 3 PE2-->+-------------+ PE1-->| PE3 |-->Compiler Generator +-------------+ . . . +-------------+ Compiler<--| Comp Gen |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Posted: 2025-12-21 Previous - Next","title":"Futamura Projection"},{"location":"post/003/#futamura-projection","text":"If you search online for Futamura Projection, it will redirect you to the Partial Evaluation Wikipedia page. So how are they related? Partial evaluation is a technique to move some of the runtime work to compile time, thereby speeding up the executable. Futamura projection is to repeatedly apply partial evaluation to an interpreter, thereby creating a JIT compiler. The following diagrams are based on a talk by Tom Stuart which explains Futamura projections in a way I can understand.","title":"Futamura Projection"},{"location":"post/003/#initial","text":"Source-->+-------------+ Input-->| Interpreter |-->Output +-------------+","title":"Initial"},{"location":"post/003/#projection-1","text":"Interpreter-->+-------------+ Source-->| PE1 |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+","title":"Projection 1"},{"location":"post/003/#projection-2","text":"+-------------+<--PE1 Compiler<--| PE2 |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+","title":"Projection 2"},{"location":"post/003/#projection-3","text":"PE2-->+-------------+ PE1-->| PE3 |-->Compiler Generator +-------------+ . . . +-------------+ Compiler<--| Comp Gen |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Posted: 2025-12-21 Previous - Next","title":"Projection 3"},{"location":"post/004/","text":"Programming Paradigms At first, there is mathematics. And then there is computation. Computation can be expressed in different ways: e.g. functional and procedural. Functional computation can be implemented by functional programming languages such as Haskell, while procedural computation can be implemented by procedural programming languages such as C/C++. Functional computation can be traced back to Lambda calculus, created by Alonzo Church in the 1930s. It carries out computation by applying transformation repeatedly. Pure functional programming languages use no variable and do not have assignment statement. On the other hand, procedural computation can be traced back to Turing Machine created by Alan Turing in the 1930s as well. It sequentially carries out instructions and use variables to present memory locations, and assignments to change the content of those locations. In a sense, the functional approach let us program at a more abstract level than the procedural approach. Besides functional and procedural, there is also logic programming, which is more about computing truth instead of carrying out tasks. There are two schools of logic programming: rules based and neural network based. The rule based approach initially took the lead (e.g. Prolog) but eventually came to a deadend. With the advancement in hardware, the neural network approach turned the tables. It surpasses all expectation and now Artificial Intelligence (AI) becomes part of our daily life. Reference Programming Languages Principles and Practice, Kenneth C. Louden Posted: 2026-01-12 Previous","title":"Programming Paradigms"},{"location":"post/004/#programming-paradigms","text":"At first, there is mathematics. And then there is computation. Computation can be expressed in different ways: e.g. functional and procedural. Functional computation can be implemented by functional programming languages such as Haskell, while procedural computation can be implemented by procedural programming languages such as C/C++. Functional computation can be traced back to Lambda calculus, created by Alonzo Church in the 1930s. It carries out computation by applying transformation repeatedly. Pure functional programming languages use no variable and do not have assignment statement. On the other hand, procedural computation can be traced back to Turing Machine created by Alan Turing in the 1930s as well. It sequentially carries out instructions and use variables to present memory locations, and assignments to change the content of those locations. In a sense, the functional approach let us program at a more abstract level than the procedural approach. Besides functional and procedural, there is also logic programming, which is more about computing truth instead of carrying out tasks. There are two schools of logic programming: rules based and neural network based. The rule based approach initially took the lead (e.g. Prolog) but eventually came to a deadend. With the advancement in hardware, the neural network approach turned the tables. It surpasses all expectation and now Artificial Intelligence (AI) becomes part of our daily life. Reference Programming Languages Principles and Practice, Kenneth C. Louden Posted: 2026-01-12 Previous","title":"Programming Paradigms"}]}