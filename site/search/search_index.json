{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"003 Futamura Projection 002 Crafting IsOdd() 001 SICP Exercise 3.2","title":"Home"},{"location":"post/001/","text":"SICP Exercise 3.2 Structure and Interpretation of Computer Programs Exercise 3.2. In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a procedure make-monitored that takes as input a procedure, f, that itself takes one input. The result returned by make-monitored is a third procedure, say mf, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to mf is the special symbol how-many-calls?, then mf returns the value of the counter. If the input is the special symbol reset-count, then mf resets the counter to zero. For any other input, mf returns the result of calling f on that input and increments the counter. For instance, we could make a monitored version of the sqrt procedure: (define s (make-monitored sqrt)) (s 100) 10 (s 'how-many-calls?) 1 Implementation #lang racket (define (make-monitored f) (define count 0) (define (mf a) (cond [(eq? a 'how-many-calls?) count] [(eq? a 'reset-count) (set! count 0)] [else (set! count (+ count 1)) (f a)] ) ) mf ) Test (define s (make-monitored sqrt)) (s 144) ; 12 (s 121) ; 11 (s 'how-many-calls?) ; 2 (s 'reset-count) (s 9) ; 3 (s 'how-many-calls?) ; 1 Epilog This is my attempt on SICP Exercise 3.2 in the programming language Racket. I am impressed that the Scheme code in the book still runs unchanged several decades later in Racket. Posted: 2025-08-19 Next","title":"SICP Exercise 3.2"},{"location":"post/001/#sicp-exercise-32","text":"Structure and Interpretation of Computer Programs Exercise 3.2. In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a procedure make-monitored that takes as input a procedure, f, that itself takes one input. The result returned by make-monitored is a third procedure, say mf, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to mf is the special symbol how-many-calls?, then mf returns the value of the counter. If the input is the special symbol reset-count, then mf resets the counter to zero. For any other input, mf returns the result of calling f on that input and increments the counter. For instance, we could make a monitored version of the sqrt procedure: (define s (make-monitored sqrt)) (s 100) 10 (s 'how-many-calls?) 1 Implementation #lang racket (define (make-monitored f) (define count 0) (define (mf a) (cond [(eq? a 'how-many-calls?) count] [(eq? a 'reset-count) (set! count 0)] [else (set! count (+ count 1)) (f a)] ) ) mf ) Test (define s (make-monitored sqrt)) (s 144) ; 12 (s 121) ; 11 (s 'how-many-calls?) ; 2 (s 'reset-count) (s 9) ; 3 (s 'how-many-calls?) ; 1 Epilog This is my attempt on SICP Exercise 3.2 in the programming language Racket. I am impressed that the Scheme code in the book still runs unchanged several decades later in Racket. Posted: 2025-08-19 Next","title":"SICP Exercise 3.2"},{"location":"post/002/","text":"Crafting IsOdd() Mutually Recursive Crafting Interpreters chapter 8 shows us an interesting way to implement IsOdd() & IsEven() by mutually calling each other recursively. Implementation in Go package main import \"fmt\" func isOdd(i int) bool { if i == 0 { return false } else { return isEven(i - 1) } } func isEven(i int) bool { if i == 0 { return true } else { return isOdd(i - 1) } } func main() { fmt.Println(isOdd(100)) // print false fmt.Println(isOdd(101)) // print true fmt.Println(isEven(100)) // print true fmt.Println(isEven(101)) // print false } Epilog Crafting Interpreters is handcrafted by Robert Nystrom. Posted: 2025-10-14 Previous - Next","title":"Crafting IsOdd()"},{"location":"post/002/#crafting-isodd","text":"Mutually Recursive Crafting Interpreters chapter 8 shows us an interesting way to implement IsOdd() & IsEven() by mutually calling each other recursively. Implementation in Go package main import \"fmt\" func isOdd(i int) bool { if i == 0 { return false } else { return isEven(i - 1) } } func isEven(i int) bool { if i == 0 { return true } else { return isOdd(i - 1) } } func main() { fmt.Println(isOdd(100)) // print false fmt.Println(isOdd(101)) // print true fmt.Println(isEven(100)) // print true fmt.Println(isEven(101)) // print false } Epilog Crafting Interpreters is handcrafted by Robert Nystrom. Posted: 2025-10-14 Previous - Next","title":"Crafting IsOdd()"},{"location":"post/003/","text":"Futamura Projection If you search online for Futamura Projection, it will redirect you to the Partial Evaluation Wikipedia page. So how are they related? Partial evaluation is a technique to move some of the runtime work to compile time, thereby speeding up the executable. Futamura projection is to repeatedly apply partial evaluation to an interpreter, thereby creating a JIT compiler. The following diagrams are based on a talk by Tom Stuart which explains Futamura projections in a way I can understand. Initial Source-->+-------------+ Input-->| Interpreter |-->Output +-------------+ Projection 1 Interpreter-->+-------------+ Source-->| PE1 |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Projection 2 +-------------+<--PE1 Compiler<--| PE2 |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Projection 3 PE2-->+-------------+ PE1-->| PE3 |-->Compiler Generator +-------------+ . . . +-------------+ Compiler<--| Comp Gen |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Posted: 2025-12-21 Previous","title":"Futamura Projection"},{"location":"post/003/#futamura-projection","text":"If you search online for Futamura Projection, it will redirect you to the Partial Evaluation Wikipedia page. So how are they related? Partial evaluation is a technique to move some of the runtime work to compile time, thereby speeding up the executable. Futamura projection is to repeatedly apply partial evaluation to an interpreter, thereby creating a JIT compiler. The following diagrams are based on a talk by Tom Stuart which explains Futamura projections in a way I can understand.","title":"Futamura Projection"},{"location":"post/003/#initial","text":"Source-->+-------------+ Input-->| Interpreter |-->Output +-------------+","title":"Initial"},{"location":"post/003/#projection-1","text":"Interpreter-->+-------------+ Source-->| PE1 |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+","title":"Projection 1"},{"location":"post/003/#projection-2","text":"+-------------+<--PE1 Compiler<--| PE2 |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+","title":"Projection 2"},{"location":"post/003/#projection-3","text":"PE2-->+-------------+ PE1-->| PE3 |-->Compiler Generator +-------------+ . . . +-------------+ Compiler<--| Comp Gen |<--Interpreter . +-------------+ . . +-------------+ Source-->| Compiler |-->Executable +-------------+ . . . +-------------+ Input->| Executable |-->Output +-------------+ Posted: 2025-12-21 Previous","title":"Projection 3"}]}